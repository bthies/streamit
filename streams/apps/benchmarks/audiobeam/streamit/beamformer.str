void->void pipeline beamformer
{
  int     num_mics = 15;
  boolean hamming  = false;
  float   sound_speed   = 342;
  float   sampling_rate = 16000;
    
  float[num_mics][3] mic_locations;
  float[3] source_location;
    
  for (int i = 0; i < num_mics; i++) {
    mic_locations[i][0] = 1.5;
    mic_locations[i][1] = 2.79 + (i * 0.03);
    mic_locations[i][2] = 0.0;
  }
    
  source_location[0] = 1.1677;
  source_location[1] = 2.1677;
  source_location[2] = 1;
    
  //  add FileReader<float>("/home/streamit/compiler-static/audiobeam/data/near-field/data2");
  add FileReader<float>("../data/data2.binary");

  //  add float->float filter { work pop 1 push 1 { float val = pop(); print(val); push(val); } } 

  add calculate_single_position(num_mics, hamming, sound_speed, sampling_rate, 
					  mic_locations, source_location);    
}


// the  most basic  mode  is to  process  the microphone  data and  to
// calculate  the output  based on  one beam  focused on  a particular
// point in space
float->void pipeline calculate_single_position(int num_mics, boolean hamming,
							     float sound_speed, float sampling_rate,
							     float[num_mics][3] mic_locations,
							     float[3] source_location)
{
  int   num_beams = 1;
    
  float[num_beams][num_mics] delays;
  int  [num_beams][num_mics] delays_floor;
  int  [num_beams][num_mics] delays_ceil;
  float[num_beams][num_mics] delays_diff;
  float[num_mics] distances;
  float[num_mics] weights;
    
  float min_delay = 1e38;
  float max_delay = 0;
  int   index     = 0;
    
  for (int i = 0; i < num_mics; i++) {
    distances[i] = sqrt(((mic_locations[i][0] - source_location[0]) *
				 (mic_locations[i][0] - source_location[0])) + 
				((mic_locations[i][1] - source_location[1]) * 
				 (mic_locations[i][1] - source_location[1])) + 
				((mic_locations[i][2] - source_location[2]) * 
				 (mic_locations[i][2] - source_location[2])));
	
    delays[0][i] = (distances[i] / sound_speed) * sampling_rate;

    if (delays[0][i] < min_delay) {
	min_delay = delays[0][i];
    }
  }
    
  min_delay = floor(min_delay) - 1;
    
  for (int i = 0; i < num_mics; i++) {
    delays[0][i] -= min_delay;
    delays_floor[0][i] = (int) floor(delays[0][i]);
    delays_ceil [0][i] = (int) ceil (delays[0][i]);
    delays_diff [0][i] = delays[0][i] - delays_floor[0][i];

    if (delays[0][i] > max_delay) {
	max_delay = delays[0][i];
    }
    
    weights[i] = 1;
  }

  max_delay = ceil(max_delay);
	  
  if (hamming) {
    if ((num_mics % 2) == 1) {
	int half = num_mics / 2;
	for (int y = -half; y <= half; y++) {
	  weights[index++] = 0.54 + 0.46 * cos(pi * y / half);
	}
    }
    else {
	int half = num_mics / 4;
	for (int z = 1; z >= -1; z -= 2) {
	  for (int y = -half; y <= half; y++) {
	    weights[index++] = 0.54 + 0.46 * cos(pi * y / half);
	  }
	}
    }
  }

  add process_signal(num_mics, num_beams, (int) max_delay, delays_floor, delays_diff, weights);

  add float->void filter {
    float time_index, time_index_increment;

    init {
	time_index = 0;
	time_index_increment = 1.0 / sampling_rate;
    }
	  
    work pop 1 {
	print(time_index);
	print(pop());
	time_index += time_index_increment;
    }
  }
}


// read in lines  of the signal and run  the beamforming algorithms on
// it:  the main  idea is  that we  have a  circular queue  of samples
// implemented via  an array  of max_delay+1 samples,  so that  we can
// keep max_delay  previous samples and  the current sample;  once the
// queue is "full", that is, we have max_delay+1 samples in it, we can
// start outputting  beamformed results (delay each  microphone by the
// appropriate amount by reading that amount into the future)
float->float pipeline process_signal(int num_mics, int num_beams, int max_delay,
						 int  [num_beams][num_mics] delays_floor,
						 float[num_beams][num_mics] delays_diff,
						 float[num_mics] weights)
{
  add distribute_samples(num_mics, num_beams, max_delay, delays_floor, weights);
  
  add float->float splitjoin {
    split roundrobin(2 * num_mics);
    
    for (int beam = 0; beam < num_beams; beam++) {
	add do_beamforming(num_mics, beam, delays_diff, weights);
    }
	  
    join roundrobin;
  }
}


float->float filter distribute_samples(int num_mics, int num_beams, int max_delay,
						   int  [num_beams][num_mics] delays_floor,
						   float[num_mics] weights)
{
  int   queue_head;
  float[max_delay + 1][num_mics] sample_queue;
    
  init {
    queue_head = 1;
	
    for (int beam = 0; beam < num_beams; beam++) {
	for (int mic = 0; mic < num_mics; mic++) {
	  sample_queue[beam][mic] = 0;
	}
    }
  }
    
  work pop num_mics push (2 * num_beams * num_mics) {
    int   low_index;
    int   high_index;
	
    for (int mic = 0; mic < num_mics; mic++) {
	sample_queue[queue_head-1][mic] = pop();
    }
	
    for (int beam = 0; beam < num_beams; beam++) {
	for (int mic = 0; mic < num_mics; mic++) {
	  int delay_floor = delays_floor[beam][mic];
		  
	  // low index gets index of sample right before desired sample
	  low_index = queue_head + delay_floor;
	  if (low_index > max_delay) {
	    low_index -= (max_delay + 1);
	  }
		  
	  // high index gets index of sample right after desired sample
	  high_index = queue_head + delay_floor + 1;
	  if (high_index > max_delay) {
	    high_index -= (max_delay + 1);
	  }

	  push(sample_queue[low_index][mic]);
	  push(sample_queue[high_index][mic]);
	}
    }

    queue_head = queue_head + 1;
    if (queue_head > max_delay) {
	queue_head = queue_head - max_delay;
    }
  }
}


// take in  a sample  and a  queue of previous  samples, and  output a
// beamformed  one-channel  sample,  incorporating timing  information
// from max_delay previous samples
float->float pipeline do_beamforming(int num_mics, int beam, 
						 float[num_beams][num_mics] delays_diff, 
						 float[num_mics] weights)
{
  add float->float splitjoin {
    split roundrobin(2);
	  
    for (int mic = 0; mic < num_mics; mic++) {
	add float->float filter {
	  work pop 2 push 1{
	    float low_sample  = pop();
	    float high_sample = pop();
	    float delay       = delays_diff[beam][mic];
	    float value       = (((high_sample - low_sample) * delay) + low_sample);

	    push(value * weights[mic]);
	  }
	}
    }
	  
    join roundrobin;
  }
    
  add float->float filter {
    work pop num_mics push 1 {
	float sum = 0;
	for (int i = 0; i < num_mics; i++) {
	  float val = pop();
	  sum += val;
	}
	push(sum / (float) num_mics);
    }
  }
}
