/* this Filter performs subband Pulse Compression.
The most computationally intensive method for Pulse Compression is FFT with overlap and save, yet since the complex number support is not yet completely supported by the compiler, I will use the convolutional filtering to perform pulse compression. For code reusablility, the code for performing the actual CubeConv is implemented in a separate file.

in the work function gets an N_bm*N_srg*N_pri Matrix as its input and the output is a N_bm*N_srg*N_pri,
the init function requires the value for float[N_pc] , the values for the steering matrix V(s) is computed during the initialization part;

*/

import streamit.*;

complex[N_bm][N_srg][N_pri]->complex[N_bm][N_srg][N_pri] pipeline PulseCmp( int N_bm,int N_srg, int N_pri,int N_pc, complex[] h_pc)
  {
      add FormChg20(N_bm,N_srg,N_pri);
      add arrayFIR(N_srg,N_pc,h_pc);
      add FormChg21(N_bm,N_srg,N_pri);	       
    }
	

}


	
	
	

	
	
	
	    


	
    
	

    






